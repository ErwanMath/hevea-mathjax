# 12 "entry.mll"
 

let buff = Out.create_buff ()
;;

let put s =
  Out.put buff s
and put_char c =
  Out.put_char buff c
;;


type res =
| Bang of string * string
| Bar of string * string
| Eof of string * string
;;

let extend r i = match r with
| Bang (p,_) -> Bang (i,p)
| Bar (p,_) -> Bar (i,p)
| Eof (p,_) -> Eof (i,p)
;;

type key = string list * string list

exception Fini
exception NoGood
;;


# 34 "entry.ml"
let __ocaml_lex_tables = {
  Lexing.lex_base = 
   "\000\000\249\255\250\255\251\255\252\255\253\255\001\000\001\000\
    \255\255\254\255\002\000\253\255\254\255\000\000\000\000\000\000\
    \000\000\000\000\001\000\001\000\000\000\000\000\000\000\255\255\
    ";
  Lexing.lex_backtrk = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\006\000\006\000\
    \255\255\255\255\255\255\255\255\255\255\002\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    ";
  Lexing.lex_default = 
   "\001\000\000\000\000\000\000\000\000\000\000\000\009\000\255\255\
    \000\000\000\000\011\000\000\000\000\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\
    ";
  Lexing.lex_trans = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\005\000\006\000\008\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\007\000\000\000\013\000\000\000\
    \000\000\000\000\000\000\000\000\016\000\017\000\019\000\000\000\
    \000\000\014\000\000\000\000\000\000\000\000\000\015\000\020\000\
    \000\000\000\000\022\000\000\000\021\000\000\000\000\000\000\000\
    \018\000\023\000\000\000\000\000\003\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \002\000\255\255\012\000";
  Lexing.lex_check = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\007\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\000\000\255\255\010\000\255\255\
    \255\255\255\255\255\255\255\255\015\000\016\000\018\000\255\255\
    \255\255\013\000\255\255\255\255\255\255\255\255\014\000\019\000\
    \255\255\255\255\021\000\255\255\020\000\255\255\255\255\255\255\
    \017\000\022\000\255\255\255\255\000\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\006\000\010\000";
  Lexing.lex_base_code = 
   "";
  Lexing.lex_backtrk_code = 
   "";
  Lexing.lex_default_code = 
   "";
  Lexing.lex_trans_code = 
   "";
  Lexing.lex_check_code = 
   "";
  Lexing.lex_code = 
   "";
}

let rec entry lexbuf =
    __ocaml_lex_entry_rec lexbuf 0
and __ocaml_lex_entry_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 45 "entry.mll"
    (put "\\\"" ; entry lexbuf)
# 140 "entry.ml"

  | 1 ->
let
# 46 "entry.mll"
            lxm
# 146 "entry.ml"
= Lexing.sub_lexeme_char lexbuf (lexbuf.Lexing.lex_start_pos + 1) in
# 47 "entry.mll"
    (put_char lxm ; entry lexbuf)
# 150 "entry.ml"

  | 2 ->
# 48 "entry.mll"
      (Bang   (Out.to_string buff,""))
# 155 "entry.ml"

  | 3 ->
# 50 "entry.mll"
    (let s = Out.to_string buff in
    let r = entry lexbuf in
    extend r s)
# 162 "entry.ml"

  | 4 ->
# 53 "entry.mll"
      (Bar (Out.to_string buff,""))
# 167 "entry.ml"

  | 5 ->
# 54 "entry.mll"
      (Eof (Out.to_string buff,""))
# 172 "entry.ml"

  | 6 ->
let
# 55 "entry.mll"
       lxm
# 178 "entry.ml"
= Lexing.sub_lexeme_char lexbuf lexbuf.Lexing.lex_start_pos in
# 55 "entry.mll"
           (put_char lxm ; entry lexbuf)
# 182 "entry.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_entry_rec lexbuf __ocaml_lex_state

and idx lexbuf =
    __ocaml_lex_idx_rec lexbuf 10
and __ocaml_lex_idx_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 59 "entry.mll"
     (let key = Save.arg lexbuf in
     let  value = Save.arg lexbuf in
     key,value)
# 195 "entry.ml"

  | 1 ->
# 62 "entry.mll"
      (raise Fini)
# 200 "entry.ml"

  | 2 ->
# 63 "entry.mll"
      (idx lexbuf)
# 205 "entry.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_idx_rec lexbuf __ocaml_lex_state

;;

# 66 "entry.mll"
 

let read_key lexbuf =
    
  let bar () = match entry lexbuf with
  | Eof (s,_) ->
      begin match s with
      | ""|"("|")" -> None
      | s ->
          if s.[0] = '(' then
            Some (String.sub s 1 (String.length s - 1))
          else
            Some s
      end
  | _         -> raise NoGood in

  let rec get_rec () = match entry  lexbuf with
    Bang (i,p) ->
      let l,see = get_rec () in
      (i,p)::l,see
  | Bar (i,p) ->
      let see = bar () in
      [i,p],see
  | Eof (i,p) -> [i,p],None in

  let separe (l,see) =
    let rec sep_rec = function
      [] -> [],[]
    | (x,y)::r ->
        if x="" then raise NoGood ;          
        let xs,ys = sep_rec r in
        x::xs,y::ys in
    let xs,ys = sep_rec l in
    ((xs,ys),see) in

  separe (get_rec ())

let read_indexentry lexbuf = idx lexbuf

# 251 "entry.ml"
